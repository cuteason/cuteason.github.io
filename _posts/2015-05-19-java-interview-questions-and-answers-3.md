---
layout: post
title: Java面试问题及回答（三）
location: 北京
date: 2015-05-19 15:45
category: tech
tags: [java, interview]
---
本文是上两篇博客[Java面试问题及回答（一）](http://sijh.github.io/2015/05/12/java-interview-questions-and-answers-1)、[Java面试问题及回答（二）](http://sijh.github.io/2015/05/18/java-interview-questions-and-answers-2)的后续，系列第三篇。

**1. 默认构造器的作用是什么？**

答：默认构造器提供了对象（的域）的默认值，Java编译器会自动创建一个默认构造器，如果类中没有构造器。

**2. 为什么main方法是静态的？**

答：因为调用静态方法不需要对象，如果main方法是非静态方法，那么JVM（Java虚拟机）会创建一个对象然后再调用main()方法，这样会导致产生额外内存分配的问题。

**3. 构造器和其他方法的区别？**

答：构造器必须和类名同名，并且不能有返回值。构造器只能被调用一次，而其他常规方法可以被调用多次。

**4. Java中的this是什么？**

答：是一个关键字，指当前对象。

**5. 什么是继承？**

答：在继承这种机制下，一个对象可以获得其他类的其他对象的所有属性和行为。它表示IS-A（是）的关系。用于代码重用和方法重载。

**6. 为什么Java不支持多重继承？**

答：为了简化语言，降低复杂度，Java类中不支持多重继承。

**注：**这个解释，额，好抽象。那为什么多重继承就复杂了呢？因为如果C继承了B，也继承了A，并且A和B中都实现了F方法，那么C调用F方法的时候，采用A的实现还是采用B的实现呢？好复杂，所以Java就不支持多重继承了。更多阅读[为什么Java不支持多重继承?](http://www.importnew.com/4604.html)

**7. 什么是空指针异常？**

答：当调用一个空对象的实例方法，或者访问一个空对象的的域等等的时候，就会抛出空指针异常。

**8. Java中的super是什么？**

答：关键字，表示直接父类对象。

**9. 什么是运行时多态？**

答：运行时多态或者动态方法调度是一个过程，在这个过程中，对被覆盖方法的调用是在运行时解析而不是在编译时解析。

**10. 什么是抽象类？**

答：被声明为abstract的类就是抽象类。它需要被继承，并且被实现里面的方法，不能被实例化。

**11. 不是抽象类可以有抽象方法吗？**

答：不可以。如果类中有任何的抽象方法，该类必须是抽象的。

**注：**但是抽象类不一定非要包含抽象方法，当然这样就没有必要，但是理论上可行。

**12. 什么是Locale类？**

答：Locale类是用来根据一个特定的地理、政治、文化地区的约定来定制程序的输出。

**13. final、finally、finalize的区别？**

-  **final**关键字，可以修饰变量、方法和类。final变量的值不能被修改，final方法不能被覆盖。（**注：final类里面的方法会自动变成final，但是类里面的域不会自动变成final。**）
-  **finally**是异常处理里面的一个块。finally块总是会被执行。
-  **finalize()**方法用在垃圾回收中，当一个对象被垃圾回收之前，会调用此方法。可用来执行任何清理程序。

**14. 什么是重载？**

答：重载是多态的一种类型。重载允许一个对象根据语境有不同的含义。

**注：**比如无参构造器和有参构造器就是重载的一种体现。

**15. 区分Java中的方法覆盖和重载？**

- 方法重载是指，同一个类中有两个或者多个名称相同，但是参数不同的方法。
- 方法覆盖是指，两个方法有相同的参数（当然也有相同的名称），但是却是不同的实现。

**注：**返回值不是方法签名的一部分。

**16. 接口可以是final的吗？**

答：不能，因为接口的实现是由其他类提供。

**17. 方法覆盖有什么限制？**

答：覆盖的方法必须有相同的方法名、参数列表、返回值。覆盖的方法不能降低被覆盖方法的可见性。

**18. 什么是构造函数链？Java中的构造函数链是如何实现的？**

答：子对象的构造函数始终需要构造它的父对象。在Java中，这是通过把隐式调用无参构造函数作为第一条语句来实现的。

**19. Java中能有虚函数吗？**

答：是的，Java中所有的函数默认都是虚函数。

**20. 静态绑定和动态绑定的区别？**

答：在静态绑定下，对象的类型在编译时就确定了；而在动态绑定下，对象的类型是在运行时确定。

**注：**更多阅读[Java中的静态绑定和动态绑定](http://droidyue.com/blog/2014/12/28/static-biding-and-dynamic-binding-in-java/)。

The end.
